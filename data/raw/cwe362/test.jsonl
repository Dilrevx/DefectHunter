{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        signal(SIGINT, helperGood);\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_18_bad()\n{\n    goto sink;\nsink:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valBadSink;\n        valBadSink = 0;\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(valBadSink);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_10StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_16_bad()\n{\n    while(1)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_18_bad()\n{\n    goto sink;\nsink:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        gBadInt = 0;\n        if (!stdThreadCreate(helperBad, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(gBadInt);\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_02StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void good6() { }"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_14StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_09StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__access_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void good7() { }"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_18_bad()\n{\n    goto sink;\nsink:\n    signal(SIGINT, helperBad);\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gGoodInt = gGoodInt + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_07StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_01StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_01_bad()\n{\n    {\n        char filename[100] = \"\";\n        struct STAT statBuffer;\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (STAT(filename, &statBuffer) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
