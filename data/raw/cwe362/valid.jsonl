{"target": 1, "func": "void CWE364_Signal_Handler_Race_Condition__basic_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        structSigAtomic *gStructSigAtomic = NULL;\n        signal(SIGINT, SIG_DFL);\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = NULL;\n        }\n        gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n        if (gStructSigAtomic == NULL) {exit(-1);}\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = gStructSigAtomic;\n        CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad->val = 1;\n        /* Assign CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad BEFORE\n         * calling 'signal', because pointer types are not (according to spec), atomic\n         * with respect to signals.\n         *\n         * In practice they are on most (all?) POSIX-y computers, but thems the\n         * rules\n         */\n        signal(SIGINT, helperBad);\n        /* FLAW: This test, free, and set operation is not atomic, so if signal\n         * delivery occurs (for example) between the free and setting to NULL,\n         * the signal handler could corrupt the heap, cause an access violation,\n         * etc\n         *\n         * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\n         * systems that don't actually exist, but this should trigger on\n         * theoretical as well as actual computer systems.\n         */\n        if (CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad != NULL)\n        {\n            free(CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad);\n            CWE364_Signal_Handler_Race_Condition__basic_15StructSigAtomicBad = NULL;\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_12StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        char filename[100] = \"\";\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FIX: Open the file without checking the status information */\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_03_bad()\n{\n    if(5==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicBad->val = 2;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            gBadInt = 0;\n            if (!stdThreadCreate(helperBad, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(gBadInt);\n        }\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char filename[100] = \"\";\n        struct STAT statBuffer;\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (STAT(filename, &statBuffer) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        gBadInt = 0;\n        if (!stdThreadCreate(helperBad, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(gBadInt);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_18_bad()\n{\n    goto sink;\nsink:\n    {\n        char filename[100] = \"\";\n        struct STAT statBuffer;\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (STAT(filename, &statBuffer) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, NULL, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(gGoodInt);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void helperGood(void *args)\n{\n    int *pIntArgs = (int *)args;\n    int i;\n    /* FIX: acquire a lock before conducting operations that need to occur\n     * atomically, and release afterwards\n     */\n    stdThreadLockAcquire(gGoodLock);\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n    stdThreadLockRelease(gGoodLock);\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__int_byref_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_05StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE366_Race_Condition_Within_Thread__global_int_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        signal(SIGINT, helperBad);\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    /* I'm going to risk going out on a limb here and making this slightly\n     * more complicated to illustrate the point: doing this in a loop a million\n     * times makes it much more \"obvious\" that something wrong might happen\n     * (you can even see it in action when you run the program)\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        gBadInt = gBadInt + 1;\n    }\n}"}
{"target": 1, "func": "void CWE479_Signal_Handler_Use_of_Non_Reentrant_Function__basic_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        signal(SIGINT, helperBad);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "static void helperBad(void *args)\n{\n    int *pIntArgs = (int*)args;\n    int i;\n    /* FLAW: incrementing an integer is not guaranteed to occur atomically;\n     * therefore this operation may not function as intended in multi-threaded\n     * programs\n     */\n    for (i = 0; i < N_ITERS; i++)\n    {\n        *pIntArgs = *pIntArgs + 1;\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_02_bad()\n{\n    if(1)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__access_03_bad()\n{\n    if(5==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (ACCESS(filename, W_OK) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char filename[100] = \"\";\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FIX: Open the file without checking the status information */\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, GOOD_SINK_STRING, strlen(GOOD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 1, "func": "static void helperBad(int sig)\n{\n    /* FLAW: malloc and free are not re-entrant */\n    /* Used to be printf in here, but we are trying to avoid that.\n     * Detecting that printLine ultimately calls printf requires inter-\n     * procedural analysis, so we cannot do that either.  So instead,\n     * do something very contrived with malloc/free\n     */\n    void *voidPointer = malloc(10);\n    if (voidPointer == NULL) {exit(-1);}\n    free(voidPointer);\n}"}
{"target": 0, "func": "void good4() { }"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valGoodSink;\n            valGoodSink = 0;\n            if (!stdThreadLockCreate(&gGoodLock))\n            {\n                return;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            stdThreadLockDestroy(gGoodLock);\n            printIntLine(valGoodSink);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            structSigAtomic *gStructSigAtomic = NULL;\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = 0;\n            }\n            gStructSigAtomic = (structSigAtomic*)malloc(sizeof(structSigAtomic));\n            if (gStructSigAtomic == NULL) {exit(-1);}\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = gStructSigAtomic;\n            CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood->val = 1;\n            /* Assign CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood BEFORE\n             * calling 'signal', because pointer types are not (according to spec), atomic\n             * with respect to signals.\n             *\n             * In practice they are on most (all?) POSIX-y computers, but thems the\n             * rules\n             */\n            signal(SIGINT, helperGood);\n            /* FIX: In this instance, the fix is to temporarily disable the signal\n             * handler while performing non-atomic operations.  Another way would\n             * be to use sigprocmask or sigvec, or to restructure the signal handler\n             * to operate in a safe manner.\n             */\n            signal(SIGINT, SIG_DFL);\n            if (CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood != NULL)\n            {\n                free(CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood);\n                CWE364_Signal_Handler_Race_Condition__basic_03StructSigAtomicGood = NULL;\n            }\n            signal(SIGINT, helperGood);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "void CWE364_Signal_Handler_Race_Condition__basic_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    if (CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood != NULL)\n    {\n        CWE364_Signal_Handler_Race_Condition__basic_11StructSigAtomicGood->val = 2;\n    }\n}"}
{"target": 0, "func": "void CWE367_TOC_TOU__stat_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE367_TOC_TOU__stat_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char filename[100] = \"\";\n            struct STAT statBuffer;\n            int fileDesc = -1;\n            if (fgets(filename, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                filename[0] = '\\0';\n            }\n            if (strlen(filename) > 0)\n            {\n                filename[strlen(filename)-1] = '\\0'; /* remove newline */\n            }\n            /* FLAW: Open and write to the file after checking the status information */\n            if (STAT(filename, &statBuffer) == -1)\n            {\n                exit(1);\n            }\n            fileDesc  = OPEN(filename, O_RDWR);\n            if (fileDesc == -1)\n            {\n                exit(1);\n            }\n            if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n            {\n                exit(1);\n            }\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        int valGoodSink;\n        valGoodSink = 0;\n        if (!stdThreadLockCreate(&gGoodLock))\n        {\n            return;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        stdThreadLockDestroy(gGoodLock);\n        printIntLine(valGoodSink);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        signal(SIGINT, helperGood);\n    }\n}"}
{"target": 0, "func": "static void helperGood(int sig)\n{\n    /* FIX: Basically, \"don't do anything\" in signal handlers.  Set a flag at\n     * best, and if you have to call a function, ensure it's a re-entrant\n     * asynchronous-safe one that doesn't eat up a lot of time\n     */\n    volatileSigAtomic = sig;\n}"}
{"target": 1, "func": "void CWE366_Race_Condition_Within_Thread__global_int_01_bad()\n{\n    {\n        stdThread threadA = NULL;\n        stdThread threadB = NULL;\n        gBadInt = 0;\n        if (!stdThreadCreate(helperBad, NULL, &threadA))\n        {\n            threadA = NULL;\n        }\n        if (!stdThreadCreate(helperBad, NULL, &threadB))\n        {\n            threadB = NULL;\n        }\n        if (threadA && stdThreadJoin(threadA))\n        {\n            stdThreadDestroy(threadA);\n        }\n        if (threadB && stdThreadJoin(threadB))\n        {\n            stdThreadDestroy(threadB);\n        }\n        printIntLine(gBadInt);\n    }\n}"}
