{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: swprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fscanf(stdin, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_02_bad()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FLAW: Failed to check return status of ImpersonateNamedPipeClient\n             * -- However, since we're not even DOING anything with the pipe\n             * it's debatable whether this is really a bug\n             */\n            ImpersonateNamedPipeClient(hPipe);\n            printLine(\"Impersonated\");\n            if (!RevertToSelf())\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Do not check the return value */\n            fgets(data, 100, stdin);\n            printLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (!ImpersonateSelf(SecurityImpersonation))\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putc_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        scanf(\"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_remove_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_01_bad()\n{\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_rename_16_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(L\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n             * but we are checking to see if the return value is equal to 0 */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fscanf(stdin, \"%99s\\0\", data);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE,\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        if (hPipe == INVALID_HANDLE_VALUE)\n        {\n            exit(1);\n        }\n        /* FIX: check for the correct return value */\n        if (!ImpersonateNamedPipeClient(hPipe))\n        {\n            exit(1);\n        }\n        CloseHandle(hPipe);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_17_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n     * we are checking to see if the return value is 0 */\n    if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        sscanf(SRC, \"%99s\\0\", data);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: snprintf() might fail, in which case the return value will be negative, but\n             * we are checking to see if the return value is 0 */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) == 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (REMOVE(L\"removemegood.txt\") != 0)\n    {\n        printLine(\"remove failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_RpcImpersonateClient_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: scanf() might fail, in which case the return value will be EOF (-1),\n             * but we are checking to see if the return value is 0 */\n            if (scanf(\"%99s\\0\", data) == 0)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check for the correct return value */\n    if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n    {\n        printLine(\"fwrite failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fwscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putchar_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putchar((int)'A');\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputc_01_bad()\n{\n    /* FLAW: Do not check the return value */\n    fputc((int)'A', stdout);\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n     * if the return value is greater than zero (true) */\n    if (ImpersonateSelf(SecurityImpersonation) > 0)\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_01_bad()\n{\n    /* FLAW: Do not check if ImpersonateSelf() fails */\n    ImpersonateSelf(SecurityImpersonation);\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-wcslen(SRC_STRING)-1, L\"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        HANDLE hMutex = NULL;\n        hMutex = CreateMutexA(NULL, FALSE, NULL);\n        /* FIX: Check the return value of CreateMutex() for NULL */\n        if (hMutex == NULL)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hMutex);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (PUTS(\"string\") == EOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_12_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_scanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (sscanf(SRC, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FIX: check for the correct return value */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_sscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: swscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (swscanf(SRC_STRING, L\"%99s\\0\", data) == 0)\n        {\n            printLine(\"swscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (swscanf(SRC_STRING, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_16_bad()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_18_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_01_bad()\n{\n    /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (PUTS(\"string\") == 0)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_scanf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check the return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: Check to see if ImpersonateSelf() fails */\n    if (!ImpersonateSelf(SecurityImpersonation))\n    {\n        exit(1);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    /* FIX: check the return value */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (wscanf(L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"wscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: fwscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == 0)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_puts_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n        HANDLE hPipe = INVALID_HANDLE_VALUE;\n        BOOL fConnected = FALSE;\n        hPipe = CreateNamedPipeW(\n                    pipeName,\n                    FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                    PIPE_TYPE_MESSAGE |\n                    PIPE_READMODE_MESSAGE |\n                    PIPE_WAIT,\n                    PIPE_UNLIMITED_INSTANCES,\n                    BUFFER_SIZE,\n                    BUFFER_SIZE,\n                    NMPWAIT_USE_DEFAULT_WAIT,\n                    NULL);\n        /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n           but we are checking to see if the return value is NULL */\n        if (hPipe == NULL)\n        {\n            exit(1);\n        }\n        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        CloseHandle(hPipe);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateMutex_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexW() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n    else\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: check for the correct return value */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (fputws(L\"string\", stdout) == WEOF)\n    {\n        printLine(\"fputws failed!\");\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putws() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(L\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"sscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fwrite_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FLAW: fread() might fail, in which case the return value will not be equal to 100-1,\n         * but we are checking to see if the return value is equal to 0 */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) == 0)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check the return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_scanf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: fwrite() might fail, in which case the return value will not be equal to strlen(data),\n         * but we are checking to see if the return value is less than 0 */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) < 0)\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_remove_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: remove() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (REMOVE(\"removemebad.txt\") == 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_snprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-strlen(SRC)-1, \"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putc((int)'A', stdout) == 0)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check for the correct return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateMutex_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check the return value */\n    if (RENAME(OLD_GOOD_FILE_NAME, \"newgoodfilename.txt\") != 0)\n    {\n        printLine(\"rename failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwrite((wchar_t *)L\"string\", sizeof(wchar_t), wcslen(L\"string\"), stdout) != wcslen(L\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fread_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateNamedPipe_03_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_07_bad()\n{\n    if(staticFive==5)\n    {\n        /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: putwc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fgets_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check the return value */\n        if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n        {\n            printLine(\"snwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticFive==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_sscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            swscanf(SRC, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeA(\n                        \"\\\\\\\\.\\\\pipe\\\\test_pipe\",\n                        PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* ConnectNamedPipe returns failure if a client connected between CreateNamedPipe and now,\n             * which isn't actually an error in terms of waiting for a client. */\n            if (!ConnectNamedPipe(hPipe, NULL) && GetLastError() != ERROR_PIPE_CONNECTED)\n            {\n                CloseHandle(hPipe);\n                exit(1);\n            }\n            /* FIX: Check if \"ImpersonateNamedPipeClient\" succeeded or not */\n            if (!ImpersonateNamedPipeClient(hPipe))\n            {\n                printLine(\"Failed to impersonate\");\n            }\n            else\n            {\n                printLine(\"Impersonated\");\n                if (!RevertToSelf())\n                {\n                    exit(1);\n                }\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputs_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: fputs() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputs(\"string\", stdout) == 0)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(L\"removemebad.txt\");\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_01_bad()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fscanf(stdin, \"%99s\\0\", data) == 0)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fputs_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check the return value */\n        fputs(\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE273_Improper_Check_for_Dropped_Privileges__w32_ImpersonateNamedPipeClient_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexA(NULL, FALSE, NULL);\n            /* FLAW: If CreateMutexA() failed, the return value will be NULL,\n               but we are checking to see if the return value is INVALID_HANDLE_VALUE */\n            if (hMutex == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fscanf_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fread_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n         * but we are checking to see if the return value is less than 0. */\n        if (fgets(data, 100, stdin) < 0)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but\n             * we are checking to see if the return value is 0 */\n            if (fscanf(stdin, \"%99s\\0\", data) == 0)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout);\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: check for the correct return value */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgets(data, 100, stdin) < 0)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalTrue)\n    {\n        /* FIX: check the return value */\n        if (putwc((wchar_t)L'A', stdout) == WEOF)\n        {\n            printLine(\"putwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        sscanf(SRC, \"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fread_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_02_bad()\n{\n    if(1)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateMutex_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_snprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: Check the return value of RpcImpersonateClient() for RPC_S_OK */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: Do not check the return value */\n        PUTS(L\"string\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(\"string\") == EOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (wscanf(L\"%99s\\0\", data) == EOF)\n        {\n            printLine(\"wscanf failed!\");\n        }\n    }\n    break;\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FIX: check for the correct return value */\n        if (fgets(data, 100, stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_fgets_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        printLine(\"Please enter a string: \");\n        /* FLAW: Do not check the return value */\n        fgets(data, 100, stdin);\n        printLine(data);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fwrite_07_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putwchar((wchar_t)L'A') == 0)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (fwrite((char *)\"string\", sizeof(char), strlen(\"string\"), stdout) != strlen(\"string\"))\n        {\n            printLine(\"fwrite failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputc((int)'A', stdout) == EOF)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fwrite_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_puts_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (PUTS(L\"string\") == WEOF)\n    {\n        printLine(\"puts failed!\");\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticTrue)\n    {\n        /* FIX: check for the correct return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fread_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_rename_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: rename() might fail, in which case the return value will be non-zero, but\n         * we are checking to see if the return value is 0 */\n        if (RENAME(OLD_BAD_FILE_NAME, NEW_BAD_FILE_NAME) == 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(5==5)\n    {\n        /* FIX: check for the correct return value */\n        if (fputs(\"string\", stdout) == EOF)\n        {\n            printLine(\"fputs failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_w32CreateNamedPipe_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: Do not check the return value */\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32CreateNamedPipe_16_bad()\n{\n    while(1)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeW() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_sscanf_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            sscanf(SRC, \"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (!ImpersonateSelf(SecurityImpersonation))\n        {\n            exit(1);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: fwprintf() might fail, in which case the return value will be negative, but\n     * we are checking to see if the return value is 0 */\n    if (fwprintf(stdout, L\"%s\\n\", L\"string\") == 0)\n    {\n        printLine(\"fwprintf failed!\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_putchar_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_02_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fgets_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check for the correct return value */\n        if (RpcImpersonateClient(0) != RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_remove_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        REMOVE(\"removemebad.txt\");\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FIX: Check the return value of CreateMutex() for NULL */\n            if (hMutex == NULL)\n            {\n                exit(1);\n            }\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_scanf_16_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fprintf_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n        wchar_t dataBuffer[100] = L\"\";\n        wchar_t * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n        {\n            printLine(\"fread failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_puts_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, NEW_GOOD_FILE_NAME) != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalFive==5)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_w32CreateMutex_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            HANDLE hMutex = NULL;\n            hMutex = CreateMutexW(NULL, FALSE, NULL);\n            /* FLAW: Do not check the return value */\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hMutex);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    goto sink;\nsink:\n    /* FIX: check for the correct return value */\n    if (RpcImpersonateClient(0) != RPC_S_OK)\n    {\n        exit(1);\n    }\n    /* We'll leave out most of the implementation since it has nothing to do with the CWE\n     * and since the checkers are looking for certain function calls anyway */\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_ImpersonateSelf_01_bad()\n{\n    /* FLAW: ImpersonateSelf() could fail and would return 0 (false), but we are checking to see\n     * if the return value is greater than zero (true) */\n    if (ImpersonateSelf(SecurityImpersonation) > 0)\n    {\n        exit(1);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_putc_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        putwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: check the return value */\n        if (RENAME(OLD_GOOD_FILE_NAME, L\"newgoodfilename.txt\") != 0)\n        {\n            printLine(\"rename failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: RpcImpersonateClient() could fail and would not return RPC_S_OK, but we\n         * are failing if the return value is RPC_S_OK */\n        if (RpcImpersonateClient(0) == RPC_S_OK)\n        {\n            exit(1);\n        }\n        /* We'll leave out most of the implementation since it has nothing to do with the CWE\n         * and since the checkers are looking for certain function calls anyway */\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n}"}
{"target": 0, "func": "void good5() { }"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_10_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32CreateNamedPipe_16_bad()\n{\n    while(1)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FLAW: If CreateNamedPipeA() failed, the return value will be INVALID_HANDLE_VALUE,\n               but we are checking to see if the return value is NULL */\n            if (hPipe == NULL)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__char_putc_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: Do not check the return value */\n        putc((int)'A', stdout);\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    while(1)\n    {\n        /* FIX: check the return value */\n        if (fprintf(stdout, \"%s\\n\", \"string\") < 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n        break;\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_01_good()\n{\n    good1();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputs_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_snprintf_14_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_w32ImpersonateNamedPipeClient_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            wchar_t * pipeName = L\"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            hPipe = CreateNamedPipeW(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE,\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFFER_SIZE,\n                        BUFFER_SIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            /* FLAW: ImpersonateNamedPipeClient() might fail, in which case the return value will be 0 (false), but\n             * we are checking to see if the return value is greater than zero (which will be true) */\n            if (ImpersonateNamedPipeClient(hPipe) > 0)\n            {\n                exit(1);\n            }\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fprintf_14_bad()\n{\n    if(globalFive==5)\n    {\n        /* FLAW: fprintf() might fail, in which case the return value will be negative, but\n         * we are checking to see if the return value is 0 */\n        if (fprintf(stdout, \"%s\\n\", \"string\") == 0)\n        {\n            printLine(\"fprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_09_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_remove_18_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_05_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fprintf_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FIX: check the return value */\n            if (fgets(data, 100, stdin) == NULL)\n            {\n                printLine(\"fgets failed!\");\n                exit(1);\n            }\n            printLine(data);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__w32ImpersonateSelf_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Do not check if ImpersonateSelf() fails */\n        ImpersonateSelf(SecurityImpersonation);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_puts_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: Do not check the return value */\n    PUTS(L\"string\");\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fread_11_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (fscanf(stdin, \"%99s\\0\", data) == EOF)\n        {\n            printLine(\"fscanf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(globalReturnsTrue())\n    {\n        /* FIX: check for the correct return value */\n        if (REMOVE(L\"removemegood.txt\") != 0)\n        {\n            printLine(\"remove failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC) < 0)\n            {\n                printLine(\"snwprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fputs_12_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fputws(L\"string\", stdout) == WEOF)\n        {\n            printLine(\"fputws failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fwrite_08_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_remove_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putc((int)'A', stdout) == EOF)\n        {\n            printLine(\"putc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putc_13_good()\n{\n    good1();\n    good2();\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_snprintf_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            SNPRINTF(data,100-wcslen(SRC)-1, L\"%s\\n\", SRC);\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__w32_RpcImpersonateClient_15_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n            {\n                printLine(\"snprintf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (swscanf(SRC, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"swscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_06_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check for the correct return value */\n        if (putwchar((wchar_t)L'A') == WEOF)\n        {\n            printLine(\"putwchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            char * pipeName = \"\\\\\\\\.\\\\pipe\\\\mypipe\";\n            HANDLE hPipe = INVALID_HANDLE_VALUE;\n            BOOL fConnected = FALSE;\n            hPipe = CreateNamedPipeA(\n                        pipeName,\n                        FILE_FLAG_FIRST_PIPE_INSTANCE, /* FILE_FLAG_FIRST_PIPE_INSTANCE - this flag must be set */\n                        PIPE_TYPE_MESSAGE |\n                        PIPE_READMODE_MESSAGE |\n                        PIPE_WAIT,\n                        PIPE_UNLIMITED_INSTANCES,\n                        BUFSIZE,\n                        BUFSIZE,\n                        NMPWAIT_USE_DEFAULT_WAIT,\n                        NULL);\n            /* FIX: Check the return value of CreateNamedPipe() for an invalid handle */\n            if (hPipe == INVALID_HANDLE_VALUE)\n            {\n                exit(1);\n            }\n            fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);\n            /* We'll leave out most of the implementation since it has nothing to do with the CWE\n             * and since the checkers are looking for certain function calls anyway */\n            CloseHandle(hPipe);\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (fwprintf(stdout, L\"%s\\n\", L\"string\") < 0)\n        {\n            printLine(\"fwprintf failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n        /* FIX: check the return value */\n        if (PUTS(L\"string\") == WEOF)\n        {\n            printLine(\"puts failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_fputc_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: fputc() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputc((int)'A', stdout) == 0)\n        {\n            printLine(\"fputc failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_rename_04_good()\n{\n    good1();\n    good2();\n}"}
{"target": 0, "func": "void CWE252_Unchecked_Return_Value__char_fprintf_01_good()\n{\n    good1();\n}"}
{"target": 0, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__char_w32ImpersonateNamedPipeClient_17_good()\n{\n    good1();\n}"}
{"target": 0, "func": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: check the return value */\n        if (putchar((int)'A') == EOF)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}"}
{"target": 0, "func": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check for the correct return value */\n            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)\n            {\n                printLine(\"fread failed!\");\n            }\n        }\n    }\n}"}
{"target": 0, "func": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FIX: check for the correct return value */\n        if (SNPRINTF(data,100-strlen(SRC_STRING)-1, \"%s\\n\", SRC_STRING) < 0)\n        {\n            printLine(\"snprintf failed!\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fputc_10_bad()\n{\n    if(globalTrue)\n    {\n        /* FLAW: Do not check the return value */\n        fputwc((wchar_t)L'A', stdout);\n    }\n}"}
{"target": 1, "func": "void CWE252_Unchecked_Return_Value__wchar_t_fscanf_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            fwscanf(stdin, L\"%99s\\0\", data);\n        }\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FIX: check the return value */\n            if (fwscanf(stdin, L\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"fwscanf failed!\");\n            }\n        }\n    }\n}"}
{"target": 1, "func": "void CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fputc_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n        /* FLAW: fputwc() might fail, in which case the return value will be WEOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (fputwc((wchar_t)L'A', stdout) == 0)\n        {\n            printLine(\"fputwc failed!\");\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}"}
